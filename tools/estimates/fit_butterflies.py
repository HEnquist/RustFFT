import sys
from matplotlib import pyplot as plt
import numpy as np
from read_bench_series import read_benches
from normalize_data import normalize
from scipy.optimize import minimize

fnames = sys.argv[1:]
data = read_benches(fnames)
data = normalize(data)

length = [2, 3, 4, 5, 6, 7, 8, 11, 13, 16, 17, 19, 23, 29, 31, 32]
multi_nbr = np.array([1,2,3,5,8,13,21,34,55,89])
plot_nbr = np.arange(1,100)

def rms_rel_diff(array1, array2, scaling):
   return np.mean(((array1 - array2)/scaling)**2)

all_cost = []
k_v = []
m_v = []
for fftlen in length:
    estimated_cost = []
    for nbr in multi_nbr:
        benchname = f"bench_planned_multi_{fftlen}_{nbr}"
        cost = data[benchname]
        estimated_cost.append(cost)
    # y = k*x + m
    #k, m = np.polyfit(multi_nbr, estimated_cost, 1)
    f = lambda x: rms_rel_diff( estimated_cost, x[0] + x[1]*multi_nbr, multi_nbr)
    x0 = [0, 1]
    res = minimize(f, x0)
    k = res.x[1]
    m = res.x[0]
    k_v.append(k)
    m_v.append(m)
    
    all_cost.append(estimated_cost)

    fig=plt.figure(fftlen)
    ax1 = fig.add_subplot(111)
    ax1.plot(multi_nbr, np.array(estimated_cost), '*')
    ax1.plot(plot_nbr, k*plot_nbr + m)
    ax1.set_ylabel('cost')

    ax2 = ax1.twinx()
    ax2.plot(multi_nbr, (k*multi_nbr + m)/np.array(estimated_cost))
    ax2.set_ylabel('estimated/measured')


print("--- Paste in scalar_planner_estimates.rs ---")
print("// --- Begin code generated by tools/estimates/fit_butterflies.py --- \n")
for fftlen, k, m in zip(length, k_v, m_v):
    print(f"const BUTTERFLY_SLOPE_{fftlen}: f32 = {k:.5f};")
    print(f"const BUTTERFLY_CONST_{fftlen}: f32 = {m:.5f};")
    print("")
    print(f"pub fn estimate_butterfly_cost_{fftlen}(repeats: usize) -> f32 {{")
    print(f"    BUTTERFLY_SLOPE_{fftlen} * repeats as f32 + BUTTERFLY_CONST_{fftlen}")
    print("}")
    print("")
print("// --- End code generated by tools/estimates/fit_butterflies.py --- \n")

plt.show()

